Credentials stored in osxkeychain.
SpeciesCounts strategy:

1. Use only global species counts; stored in a single SharedMemoryCellState. Eliminate
local species counts. 
Convert all global accesses, like this:
    model.speciesCounts[species.species.index, species.compartment.index]
to SharedMemoryCellState accesses, like these:
    theSharedMemoryCellState.read( time, species )
    theSharedMemoryCellState.adjust_discretely( time, adjustments )
    theSharedMemoryCellState.adjust_continuously( time, adjustments )
This will eliminate local species counts, which are not necessary. Local derived values, such as concentrations, will need to be modified. Global accesses will need to refer to species by name. Reads will emply interpolation on counts updated by a continuous model. 

Steps:
a) model.py, b) submodel.py, c) classes derived from submodel 
(might need to make changes in tutorial first.)

Time: deeply embed time in all operations 
Can assume simulation begins at 0; all model components derived from SimulationObject, which contains a time attribute.

Architecture & interfaces

Random number streams

Would be good to avoid mapping back and forth between counts and concentrations, unless absolutely necessary.

2. Move private species into local count states. Move global state into a separate Simulation object. Convert count accesses into simulation event messages. 
